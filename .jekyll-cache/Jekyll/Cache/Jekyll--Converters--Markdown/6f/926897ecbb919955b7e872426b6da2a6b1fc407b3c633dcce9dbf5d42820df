I"e<h1 id="research">Research</h1>

<p>I am interested in building systems that enable developers
to maximize the available resources. One such resource that
I have been looking into recently is: code reuse. Enormous amount 
of code has been built in the past few decades and a siginficant 
chunk is available in the form of binaries and/or source code to the
public. Developers take an active interest in contributing
to open source projects and open sourcing their own projects.
As of 2021, GitHub hosts around [200 million] repositories and 
it is expected to increase over time. To successfully use this 
code, users are going to need tools and techniques to 1) identify
repositoriey that offer functionality relevant to the user 2) analyze 
the code for possible defects and inefficiencies 3) automatically update
the code.
I have been working on addressing some of the challenges.</p>

<h2> Search </h2>
<p>Software developers must often replace existing components in
their systems to adapt to evolving environments or tooling. While
 traditional code search systems are effective at retrieving components 
 with related functionality, it is much more challenging to
 retrieve components that can be used to directly replace existing
 functionality, as replacements must account for more fundamental 
 program properties such as type compatibility. To address this
 problem, we built ClassFinder, a system which given a query
 class Q, and a search corpus S, returns a ranked subset of classes
 that can replace Q and its functionality.</p>

<p>More details on ClassFinder will be available soon!</p>
<h2> Analyze </h2>

<p>Concurrency bugs can be immensely disruptive and can cause unexpected 
 program behaviors such as deadlocks, atomicity violations, data races, 
 program crashes etc in multi-threaded programs. In some cases, these 
 bugs have manifested in safety critical systems costing human lives. 
 A multi-threaded program may accidentally import a concurrency bug by 
 accessing a third party library that contains such defects. In such cases, 
 the program will need additional synchronization mechanisms to avoid these 
 bugs, which requires a clear understanding of the bugs present in the library. 
 Concrete tests that expose the defects in the library are useful to understand the defects.</p>

<p>Writing effective tests that can expose concurrency bugs requires addressing 
 the following questions 1) What are the combination of library APIs that must 
 be invoked by the test in parallel?  2) What is the necessary program state 
 that can expose the defect and how to create it? 3) What is the execution 
 schedule that must be enforced on the tests to expose the defect? Manually 
 inspecting libraries to write effective tests that address all the above concerns 
 can be an arduous and a time consuming task. Further, in many cases the library 
 may be developed by a third party and/or the user may not have access to the 
 libraryâ€™s source code, thus adding further hurdles. Therefore we need automated 
 targeted techniques that can build effective tests that can expose concurrency 
 defects in libraries.</p>

<p><b> Replace </b></p>
:ET